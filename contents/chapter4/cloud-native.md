# 什么是云原生？

云原生(CloudNative)是一个很抽象的概念，单从字面很难理解它的意思。 我最早看一些概念性的说明和定义，被绕的云里雾里，也被CNCF 云原生全景图（CNCF cloud native landscape）吓了一跳。理解云原生，还真是需要耗费一些精力...

## 理解云原生

在这里我试图从我的角度阐述我对云原生的理解。理解一个复杂的技术有时候换一种方式会有更好的效果，比如分析TLS，作为设计者从如何设计一个加密协议出发会更彻底的了解HTTPS。对于明白什么是云原生，我们也可以先反着来，从明白什么不是云原生开始

最近这几年云厂商喊的最响亮的口号就是“上云”，上云的意思很简单：就是把企业原有基于私有数据中心业务迁移到云商的平台中。这部分的业务可以理解成云计算时代的“拆迁户”。离开了之前适配的环境，在云平台修修改改，也能勉强运行。这些上云的业务，就不是云原生业务。

当上云的阶段逐渐过去之后，开始逐渐出现在云商部署的业务，这些业务没有迁移的历史包袱，会充分利用“云”的特点来设计和满足业务的需求，业务变成了类似于云平台派生出来的产物。这些业务相当于“云”原住民，这就是云原生的字面意思。

容器以及服务编排kubernetes的出现加速了云原生技术的发展，但若想理解云原生，不应该先关注这些技术，而是理解需要这些技术的业务。

云原生的业务实质都是“在线”业务，现代互联网业务在线的要求可不简单：

- 首先业务不能中断，服务不能挂，比如要求服务的可用性指标 99.999%
- 其次业务迭代升级用户要无感知
- 最后不论流量如何，服务都应该能随时适应这种流量变化

这些要求就决定了支撑“云原生”业务的技术所应具备的特点：高可用、快速迭代/交付、资源按需分配。

看起来就很符合容器、K8S、Microservice、DevOps、CI/CD那一套了？但好像虚拟化技术也可以搞高可用、DevOps、按需分配资源那套，这么说没错，功能都可以实现，但在线（云原生）业务提出的是对性能、质量要求，不仅仅是容器更加轻量，更易扩展，同时也是新一代治理方式、管理手段的要求。

> “云原生”修饰的并不是哪种技术，而是业务。直接讲“云原生技术”并不合适，而应该是“云原生业务”和“支撑云原生业务的技术”。


所以，并不是因为云计算/容器技术发展普及了，才出现了“云原生”这个概念，而是有了亿级DAU产品、有了成千上万微服务协调的场景出现，才有了云原生技术出现和发展。从根上讲，驱动技术发展演进的动力有很多，但能让技术大行其道的动力都是来自于业务盈利的需求。


## 云原生方法论

云原生如果从技术上划分包含以下几个方法论：

- 容器化：作为应用包装的载体
- 持续交付：利用容器的轻便的特性，构建持续集成和持续发布的流水线
- DevOps：开发与运维之间的协同，上升到一种文化的层次，能够让应用快速的部署和发布
- 微服务：这是应用开发的一种理念，将单体应用拆分为微服务才能更好的实现云原生，才能独立的部署、扩展和更新

<div  align="center">
	<img src="/assets/chapter4/cloud-native-architecutre-mindnode.jpg" width = "550"  align=center />
</div>

## 微服务

解决单体应用复杂度最好的办法就是分解，对具有独立


随着服务和容器数量的激增，精心编排和管理大型容器组迅速成为关键挑战之一。 Kubernetes 是开源容器编排平台，由于出色的功能，已成为最受欢迎的编排解决方案之一。


## 云原生操作系统: Kubernetes

Kubernetes（也称为“k8s”或“kube” ）是一个容器编排平台，用于调度以及自动部署、管理和扩展容器化应用。Kubernetes 最初由 Google 工程师开发，后来于 2014 年开源。 它的前身是 Borg， 这是 Google 内部使用的一种容器编排平台。

如今，Kubernetes 和更广泛的容器生态系统正在逐渐成熟，形成一个通用的计算平台和生态系统 - 虚拟机 (VM) 是现代云基础架构和应用的基础构建块，它即使没有超越虚拟机，也可以与之抗衡。 此生态系统使组织能够提供高生产力的平台即服务 (PaaS)，解决围绕云原生开发、与基础架构和运营相关的多个任务及问题，从而使开发团队可以仅专注于编码和创新。     



### 服务网格

服务网格 (Service Mesh) 用于管理服务之间的网络流量，是云原生的网络基础设施层。也是 Kubernetes 云原生应用的重要组成部分。

如果用一句话来解释什么是 Service Mesh，可以将它比作是微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP/IP 这一层，同样使用 Service Mesh 也就无须关心服务之间的那些原本通过服务框架实现的事情。


<div  align="center">
	<img src="/assets/chapter4/service-mesh-arch.png" width = "500"  align=center />
</div>

Service Mesh 作为 sidecar 运行，对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 serivce mesh 中实现。

举一个例子来说明Service Mesh的作用：比如有两个依赖的微服务：Service A（Container1）、Service B（Container2）。这时候需要对Service A进行升级，在服务网格的管理下只需要新启一个（Container3），使用几条配置可以立即替换 Service B的调用，如果出现调用/兼容问题，则可以使用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更 —— 这些变更对其他容器是完全透明的。

通过上面的例子其实也可以看出Service Mesh 并没有给我们带来新功能，早在容器盛行以前，Service Mesh边车代理方式就已有了成功的应用案例，它是用于解决其他工具已经解决过的问题，只不过这次是在以 Kubernetes 为基础的云原生生态环境下的实现。


