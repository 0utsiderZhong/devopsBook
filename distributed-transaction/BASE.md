# 5.3.1 可靠事件队列

2008 年，eBay 的系统架构师 Dan Pritchett 在 ACM 发表了论文 “Base: An Acid Alternative“[^1]，论文中 Dan Pritchett 基于实践总结出一种独立于 ACID 获得强一致性之外的、通过引入消息队列和幂等来达成一致性目的系统化技术手段，并提出了最终一致性的概念。

从论文的名字中就可以看出：最终一致性的概念与 ACID 强一致性对立。因为 ACID 在英文中有的”酸“的含义，这个模型明显刻意拼凑成 BASE（BASE 英文中有碱的含义）。有 ACID vs BASE（酸 vs 碱）这个计算机浑然天成的梗，Dan Pritchett 论文被广泛传播，BASE 理论和最终一致性也被大家熟悉。

:::tip BASE
BASE 分别是 Basically Available(基本可用)、Soft State（软状态）和 Eventually Consistent（最终一致性）三个短语的缩写。其核心思想即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性
:::

Dan Pritchett 在论文中的提出的实现最终一致性技术手段非常有价值，总结可称为基于**可靠事件队列**的事件驱动模式，可靠事件队列关键在于可靠事件的投递和避免事件重复消费（幸运地是现在流行的消息中间件都实现了事件的持久化和 at leastonce 的投递模式，幂等性的实现也有了成熟的方案，所以这些要求也不再是问题）。

下面笔者以一个具体的说明 Dan Pritchett 提出的”可靠事件队列“的具体做法。

例如，在一个电商系统中，下单需要三个服务支持。

- 访问支付服务，通知银行扣款
- 访问库存服务，扣除购买商品的库存
- 访问积分服务，为用户增加积分。


在这个模型中，最核心、出错影响最大的服务优先处理，即：支付扣款 -> 仓库出库 -> 为用户增加积分。

- 支付服务进行扣款操作，如果扣款成功，则在自己的数据库内建立一张消息表，表内如下结构：事务ID，扣款￥100（状态：已完成），仓库出库（状态：待进行），赠送积分(状态：待进行)。
- 在系统内建立一个消息服务，定时轮询消息表，将状态是”进行中“的消息同时发送到库存和积分服务区。这个时候会产生以下几种情况：
	- 库存服务和积分服务都顺利完成了出库和加分的工作，向订单服务返回执行结果，账单服务把消息改为”已完成“。整个事务顺利完成，最终实现一致性。
	- 库存服务和仓库服务完成了收款和，但回复的消息因为网络问题丢失了，此时订单服务仍会重复发出下一条消息，但因为操作具备幂等性，所以不会导致重复出库等，只会导致仓库服务重新发送一条应答消息，此过程持续自动重复至双方通信恢复正常。


## BASE 理论应用

BASE 理论应用与多个微服务之间的调用。微服务的架构中，一个用户的请求往往需要多个服务配合才能完成，对于一个强一致性系统的可用性，都是所依赖服务可用性的乘积，例如，在一个事物中，涉及三个服务的操作，假设每个服务的可用性为 99.9%，则整个事务的可用性为 `99.9% * 99.9% * 99.9% ≈ 99.7%`。

现代的应用架构中，通常由几十甚至几百个微服务组成，对于如何提高整体系统的可用性，可用 BASE 理论进行指导，在允许存在软状态的基础上，我们只需要保证整个事务的基本可用性和最终一致性即可，并不需要保证实时一致性，保障性的设计，通常采用异步补偿机制。



<div  align="center">
	<img src="../assets/base.png" width = "500"  align=center />
</div>

以上这种依靠持续重试来保证可靠性的解决方案实际并不是 Dan Pritchett 的独创，它在计算机的其他领域中被频繁使用，也有了专有的名称 -- ”最大努力交付“（Best-Effort Delivery）。而可靠事件队列还有一种更普遍的形式，被称为”最大努力一次提交“（Best-Effort 1PC），指的是**将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式来促使同一个分布式事务中其他关联的业务全部完成**。

[^1]: 参见 https://queue.acm.org/detail.cfm?id=1394128

