#tap/tun

tap/tun 提供了一台主机内用户空间的数据传输机制。它虚拟了一套网络接口，这套接口和物理的接口无任何区别，可以配置 IP，可以路由流量，不同的是，它的流量只在主机内流通。

tap 和 tun 虽然都是虚拟网络设备，但它们的工作层次

- tap 是一个二层设备（或者以太网设备），只能处理二层的以太网帧；
- tun 是一个点对点的三层设备（或网络层设备），只能处理三层的 IP 数据包。

作为网络设备，tap/tun 也需要配套相应的驱动程序才能工作。tap/tun 驱动程序包括两个部分，一个是字符设备驱动，一个是网卡驱动。
字符驱动负责数据包在内核空间和用户空间的传送，网卡驱动负责数据包在 TCP/IP 网络协议栈上的传输和处理。

<div  align="center">
	<img src="/assets/chapter4/tun-tap.png" width = "450"  align=center />
</div>


设备文件充当了用户空间和内核空间通信的接口。当应用程序打开设备文件时，驱动程序就会创建并注册相应的虚拟设备接口，一般以 tunX 或 tapX 命名。当应用程序关闭文件时，驱动也会自动删除 tunX 和 tapX 设备，同时也会删除已经建立起来的路由等信息。


### tap/tun 和网络协议栈的数据

tap/tun 通过实现相应的网卡驱动程序来和网络协议栈通信。一般的流程和物理网卡和协议栈的交互流程是一样的，不同的是物理网卡一端是连接物理网络，而 tap/tun 虚拟网卡一般连接到用户空间。

如下图的示意图，我们有两个应用程序 A、B，物理网卡 eth0 和虚拟网卡 tun0 分别配置 IP：10.1.1.11 和 192.168.1.11，程序 A 希望构造数据包发往 192.168.1.0/24 网段的主机 192.168.1.1。

基于上图，我们看看数据包的流程：

- 应用程序 A 构造数据包，目的 IP 是 192.168.1.1，通过 socket A 将这个数据包发给协议栈。
- 协议栈根据数据包的目的 IP 地址，匹配路由规则，发现要从 tun0 出去。
- tun0 发现自己的另一端被应用程序 B 打开了，于是将数据发给程序 B.
- 程序 B 收到数据后，做一些跟业务相关的操作，然后构造一个新的数据包，源 IP 是 eth0 的 IP，目的 IP 是 10.1.1.0/24 的网关 10.1.1.1，封装原来的数据的数据包，重新发给协议栈。
- 协议栈再根据本地路由，将这个数据包从 eth0 发出。

后续步骤，当 10.1.1.1 收到数据包后，会进行解封装，读取里面的原始数据包，继而转发给本地的主机 192.168.1.1。当接收回包时，也遵循同样的流程。在这个流程中，应用程序 B 的作用其实是利用 tun0 对数据包做了一层隧道封装。可以看出 tun 设备的最大用途就是用于隧道通信的。