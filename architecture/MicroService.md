# 1.6.1 微服务

:::tip  
A microservices architecture as a service‑oriented architecture composed of loosely coupled elements that have bounded contexts.
:::

这里有两个核心概念，一是 Loosely Coupled（松耦合），二是 Bounded Context（限界上下文）。
1. Loosely Coupled（松耦合）意味着每个服务可以独立的更新，更新一个服务无需要求改变其他服务。
2. Bounded Contexts 概念来自 Eric Evans 写的 《Domain -Driven Design 》这本书，Bounded Context 意味着每个服务要有明确的边界性，你可以只关注自身软件的发布，而无需考虑谁在依赖你的发布版本。微服务和它的消费者严格通过 API 进行交互，不共享数据结构、数据库、POJO 等等。

综合上述，也就说微服务要实现独立部署，拥有独立的技术栈、界定上下文，明确所有权等。

如下图，单体服务（Monolith Application）与微服务（MicroServices）的形象对比。
<div  align="center">
	<img src="../assets/Monolith-vs-MicroService.png" width = "480"  align=center />
	<p>图 1-6 单体服务和微服务的对比</p>
</div>

单体服务就是把所有的东西放在一个大盒子里，这个大盒子里面什么都有。微服务更像是集装箱，每个箱子里面包含特定的功能模块，所有的东西可以很灵活的拆分和组装。



:::tip 微服务架构（Microservices）

微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。
:::

## 1. 微服务出现的背景

在过去很长一段时间内，传统软件大部分是各种独立单体应用，单体应用的问题总结来说扩展性差、可靠性不高、维护成本高。随着软件开发技术的发展，以及面向服务体系架构（SOA）的引入，上述问题在一定程度上得到了缓解，但由于SOA早期使用的是总线模式，与技术栈有一定的强绑关系，导致很多企业遗留系统很难对接，且切换时间长、成本高，新系统稳定性的收敛也需要一定时间。

为了摆脱这一困境，微服务应运而生。作为SOA的变体，微服务将应用程序构造为一组松散耦合的服务，在微服务体系架构中，服务是细粒度，协议是轻量级的。


微服务（或微服务架构）是一种云原生架构方法，其中单个应用程序由许多松散耦合且可独立部署的较小组件或服务组成。这些微服务相对独立，通过解耦研发、测试与部署流程来提高整体迭代效率。此外，微服务模式通过分布式架构对应用进行水平扩展和冗余部署，从根本上解决了单体应用在扩展性和稳定性存在的先天缺陷。

但需要注意的是，微服务模式也面临分布式系统的挑战，如 如何建立负载均衡体系、如何监控以及调试分布式服务、如何面向大规模复杂服务体系的部署与运维等。

在云原生时代，应用构建在云平台所提供的基础设施和基础服务之上，充分利用云服务所带来的便捷性和稳定性，可以显著降低应用架构的复杂度，让应用具备更好的可观测性、可控性、容错性等。


援引周志明老师在《凤凰架构》的观点。

:::tip <i></i>
微服务时代充满着自由的气息，微服务时代充斥着迷茫的选择。软件架构不会止步于自由，微服务仍不是架构探索终点，如果有下一个时代，笔者希望是信息系统能同时拥有微服务的自由权利，围绕业务能力构建自己的服务而不受技术规范管束，但同时又不必以承担自行解决分布式的问题的责任为代价。管他什么利弊权衡！小孩子才做选择题，成年人全部都要！
:::

## 2. 微服务架构的演进

自2011年微服务架构理念提出以来，10余年间一批又一批技术框架和理念不断涌现出来，按照笔者的理解，这期间典型的架构模式已经迭代了四代。

在第一代微服务架构中，以RPC通信为代表，首要解决的是微服务之间的通信问题。技术框架代表如阿里 Dubbo，跨语言平台的框架 Thrift、gRPC...
这个阶段，特别是早期版本的 RPC 框架，应用除了要实现业务逻辑之外，还需要自行解决上下游寻址、通信以及容错等问题。随着服务规模的扩大，服务寻址逻辑也愈加变的复杂，哪怕是同一种开发语言的另外一个应用，上述的微服务基础能力也要再重新实现一遍。


<div  align="center">
	<img src="../assets/micro-service-arc-1.png" width = "320"  align=center />
</div>

在第二代微服务架构中，服务治理逻辑 SDK 化。旁路服务注册中心作为协调者完成服务的自动注册和发现，服务之间的通信以及容错机制开始模块化，并形成独立的服务框架。

这个阶段比较有代表性的框架如 Dubbo、Spring Cloud，只需要少量代码和注解，即可集成各种所需的服务治理能力。

但随着服务框架内功能日益繁多，复用不同开发语言的基础功能就会十分苦难，这也意味着微服务的开发人员被迫绑定在某种特定语言之下，从而违背了微服务敏捷迭代的原则。
<div  align="center">
	<img src="../assets/micro-service-arc-2.png" width = "320"  align=center />
</div>


第三代微服务架构就是云原生时代的微服务架构，出现了服务网格的概念。原来被模块化到服务框架的微服务基础能力，从一个SDK演进成为一个独立的进程 - Sidecar（边车）。这个变化使得第二代架构中多语言支持问题得到了彻底解决，微服务基础能力演进和业务迭代解耦。边车进程开始接管微服务应用之间的流量，承载第二代微服务架构中服务框架的功能，包括如服务发现、调用容错以及服务治理能力，具体如权重路由、灰度路由、流量重放等。

这个阶段比较有代表性的框架如 Linkerd、Istio 等

<div  align="center">
	<img src="../assets/micro-service-arc-3.png" width = "480"  align=center />
</div>


第四代微服务架构是目前业界提出的多运行时微服务架构，利用最近的 FaaS 和 AWS 的 Lambda 等无服务器技术来进一步简化微服务的开发和交付。

在第四代微服架构中，微服务由一个应用进一步简化为微逻辑(Micrologic)，变成短暂的功能的集合。 

这中新型的架构也对边车模式提出了更高的要求，更多可复用的分布式能力从应用中剥离，并下沉到边车中，例如状态管理、资源绑定、链路追踪、事务管理等。同时，开发侧开始提倡面向localhost编程的理念，并提供标准API屏蔽底层资源、服务、基础设施之间的差异，以进一步降低微服务的开发难度。

目前比较有代表性的框架如 Dapr。

<div  align="center">
	<img src="../assets/micro-service-arc-4.png" width = "480"  align=center />
</div>