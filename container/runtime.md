# 7.4 从 OCI 到 CRI

容器本质上就是一个特殊的进程，通过 namespace 实现资源（网络、文件系统等）隔离，通过 cgroups 实现资源（CPU、内存）限制。要把进程运行在容器中，还需要有便捷的 SDK 或命令来调用 Linux 的系统功能，从而创建出容器。在程序中有个 runtime 的概念，代码范畴的runtime 指的是为了运行特定语言而提供的特定实现和设计，而到容器中涉及拉取镜像创建、启动、运行、销毁等范畴的生命周期管理，这便是 container runtime（容器运行时）。

作为容器技术早期的项目 Docker，靠的是优秀的理念，以一个“好点子”（镜像）引爆了一个时代，如上面所说，这个”好点子“也并不是特别复杂的技术，笔者相信就算没有 Docker 也会有 Cocker 或者 Eocker 的出现，而 Kubernetes 的成功不仅有 Google 深厚的技术功底作支撑，有领先时代的设计理念，更加关键的是 Kubernetes 的出现符合所有云计算大厂的切身利益，有着业界巨头不遗余力的广泛支持，它的成功便是一种必然。

Kubernetes 与 Docker 两者的关系十分微妙，把握住两者关系的变化过程，是理解 Kubernetes 架构演变与 CRI、OCI 规范的良好线索。