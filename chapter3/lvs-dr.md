# LVS的应用

LVS在应用上，一般配合Keepalived利用 VRRP协议实现主备，或者利用ECMP等价路由协议实现双活的部署方式，这个在后面会进行讲解，而在LVS本身我们主要了解两个技术点：调度的算法和工作模式。

## 调度算法

在LVS中，调度算法分为两种：静态算法、和动态算法。

静态算法主要根据LVS本身自由的固定的算法分发用户请求，主要有：

- 轮询(rr) 调度器会把所有的请求平均分配给每个RS
- 加权轮询(wrr) 安装权重比例分配用户请求。权重越高，被分配到处理的请求越多
- 源地址散列（sh） 同一个用户ip的请求，会由同一个RS来处理。
- 目标地址散列（dh） 根据url的不同，请求到不同的RS

动态算法会根据流量的不同，或者服务器的压力不同来分配用户请求，主要有：

- 最小连接数（lc） 把新的连接请求分配到当前连接数最小的服务器
- 加权最少连接数 (wlc) 服务器的处理性能用数值来代表，权重越大处理的请求越多
- 最短期望延迟 (sed) 特殊的wlc算法
- 最少队列调度(nq) 永不使用队列。如果有RS的连接数等于0，则直接把这个请求分配过去，不需要在排队等待运算了

这么多调度算法，但在LVS在实际使用过程中，负载均衡算法用的较多的分别为wlc或wrr，简单易用。

## LVS 工作模式 
默认的LVS版本有3种工作模式，DR、NAT、Tunnel。不过一些开源的LVS也提供了FullNAT模式。

> FullNAT并没有合进到内核主线版本，需要安装使用 https://github.com/alibaba/lvs 

每种模式工作原理都不同，都有自己的优缺点和不同的应用场景，下面通过对这三种模式的讲解，说明LVS几种工作模式在业务上的选择。

### DR 模式实现解析

DR(Direct Routing)是直接路由模式。优缺点都比较明显，优点是：响应数据不经过 DS，性能高、对数据包修改小，信息保存完整（携带客户端源 IP）。缺点是：DS 与 RS 必须在同一个物理网络（不支持跨机房）、服务器上必须配置 lo 和其它内核参数、不支持端口映射。


如下图示例，我们根据一个数据包的流转来分析 DR 模式的实现策略。

<div  align="center">
	<img src="/assets/chapter3/lvs-dr.png" width = "560"  align=center />
</div>

- 当客户端请求时，请求数据包穿过网络到达LVS服务器网卡：源IP是客户端IP地址CIP，目的IP是对外的服务器IP地址，也就是VIP。此时源MAC地址是CMAC，其实是LVS连接的路由器的MAC地址，目标MAC地址是VIP对应的 MAC, 记为VMAC。

- 当数据包经过链路层到达 PREROUTING 位置，查找路由发现目的IP是LVS的VIP，就会递送到INPUT链上，此时数据包 MAC、IP、Port都没有修改。

- 数据包到达INPUT链，INPUT是LVS主要工作的位置。此时LVS会根据目的IP和Port来确认是否是LVS定义的服务。如果是定义过的VIP服务，就会根据配置信息，从真实服务器列表中选择一个作为RS1，然后以RS1作为目标查找 Out 方向的路由，确定一下跳信息以及数据包要通过哪个网卡发出。最后将数据包投递到 OUTPUT 链上。

- 数据包通过 POSTROUTING 链后，从网络层转到链路层，将目的 MAC 地址修改为 RealServer 服务器 MAC 地址，记为 RMAC；而源 MAC 地址修改为 LVS 与 RS 同网段的 selfIP 对应的 MAC 地址，记为 DMAC。此时，数据包通过交换机转发给了 RealServer 服务器

- 请求数据包到达后端真实服务器后，链路层检查目的 MAC 是自己网卡地址。

- 到了网络层，查找路由，目的IP是VIP（lo上配置了VIP），判定是本地主机的数据包，经过协议栈拷贝至应用程序（比如 nginx 服务器），nginx 响应请求后，产生响应数据包。然后以CIP查找出方向的路由，确定下一跳信息和发送网卡设备信息。此时数据包源、目的IP分别是VIP、CIP。而源MAC地址是RS1的RMAC，目的MAC是下一跳（路由器）的MAC 地址，记为CMAC。然后数据包通过 RS 相连的路由器转发给真正客户端，完成了请求响应的全过程。

从整个过程可以看出，DR 模式LVS逻辑比较简单，数据包通过直接路由方式转发给后端服务器，而且响应数据包是由RS服务器直接发送给客户端，不经过LVS。通常请求数据包会比较小，响应报文较大，经过LVS的数据包基本上都是小包，所以这也是LVS的DR模式性能强大的主要原因。

### NAT模式实现解析

NAT模式双向流量都经过LVS，因此NAT模式性能会存在一定的瓶颈。不过与其它模式区别的是，NAT 支持端口映射，且能够支持 Windows 操作系统。

如下图示例，我们根据一个数据包的流转来分析 NAT 模式的实现策略。

<div  align="center">
	<img src="/assets/chapter3/lvs-nat.png" width = "580"  align=center />
</div>

- 用户请求数据包经过层层网络，到达LVS网卡，此时数据包源IP是CIP，目的IP是VIP。
- 经过网卡进入网络层 PREROUTING 位置，根据目的 IP 查找路由，确认是本机 IP，将数据包转发到 INPUT 上，此时源、目的 IP 都未发生变化。

- 到达 LVS 后，通过目的 IP 和目的 port 查找是否为 IPVS 服务。若是 IPVS 服务，则会选择一个 RS 作为后端服务器，将数据包目的 IP 修改为 RIP，并以 RIP 为目的 IP 查找路由信息，确定下一跳和出口信息，将数据包转发至 output 上。

- 修改后的数据包经过 POSTROUTING 和链路层处理后，到达 RS 服务器，此时的数据包源 IP 是 CIP，目的 IP 是 RIP。

- 到达 RS 服务器的数据包经过链路层和网络层检查后，被送往用户空间 Nginx 程序。Nginx 程序处理完毕，发送响应数据包，由于 RS 上默认网关配置为 LVS 设备 IP，所以 nginx 服务器会将数据包转发至下一跳，也就是 lvs 服务器。此时数据包源 IP 是 RIP，目的 IP 是 CIP。

- LVS 服务器收到 RS 响应数据包后，根据路由查找，发现目的 IP 不是本机 IP，且 lvs 服务器开启了转发模式，所以将数据包转发给 forward 链，此时数据包未作修改。

- LVS 收到响应数据包后，根据目的 IP 和目的 port 查找服务和连接表，将源 IP 改为 VIP，通过路由查找，确定下一跳和出口信息，将数据包发送至网关，经过复杂的网络到达用户客户端，最终完成了一次请求和响应的交互。

### Tunnel 模式实现解析

LVS中的Tunnel模式类似DR，也是一种单臂的模式，只有请求数据会经过DS，响应数据直接从后端服务器发送给客户端，性能也很强大，同时支持跨机房。不过国内运营商有一定特色性，比如 RS 的响应数据包的源 IP 为 VIP，VIP 与后端服务器有可能存在跨运营商的情况，很有可能被运营商的策略封掉。

如下图示例，我们根据一个数据包的流转来分析 Tunnel 模式的实现策略。

<div  align="center">
	<img src="/assets/chapter3/lvs-tunnel.png" width = "560"  align=center />
</div>

- 用户请求数据包经过多层网络，到达LVS网卡，此时数据包源IP是cip，目的ip是vip。
- 经过网卡进入网络层prerouting位置，根据目的ip查找路由，确认是本机ip，将数据包转发到input链上，到达lvs，此时源、目的ip都未发生变化。
- 到达lvs后，通过目的ip和目的port查找是否为IPVS服务。
若是IPVS服务，则会选择一个rs作为后端服务器，以rip为目的ip查找路由信息，确定下一跳、dev等信息，然后IP头部前边额外增加了一个IP头（以dip为源，rip为目的 ip），将数据包转发至 output 上。
- 数据包根据路由信息经最终经过 lvs 网卡，发送至路由器网关，通过网络到达后端服务器。
- 后端服务器收到数据包后，ipip模块将 Tunnel 头部卸载，正常看到的源 ip 是 cip，目的 ip 是 vip，由于在 tunl0 上配置 vip，路由查找后判定为本机 ip，送往应用程序。应用程序 Nginx 正常响应数据后以 vip 为源 ip，cip 为目的 ip 数据包发送出网卡，最终到达客户端。


### FullNat模式 

LVS 当前应用主要采用 DR 和 NAT 模式，但这 2 种模式要求 RealServer 和 LVS 在同一个 vlan中，导致部署成本过高。TUNNEL 模式虽然可以跨 vlan，但 RS
上需要部署 ipip 模块等，网络拓扑上需要连通外网，较复杂，不易运维。

为了解决上述问题，我们在 LVS 上添加了一种新的转发模式：FULLNAT，该模式和 NAT 模式的区别是：Packet IN 时，除了做 DNAT，还做 SNAT（用户 ip->内
网 ip），从而实现 LVS-RealServer 间可以跨 vlan 通讯，RealServer 只需要连接到内网。


- client主机（cip）将请求发往前端的负载均衡器（vip），请求报文源地址是CIP，目标地址为VIP。负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的源MAC地址改为自己DIP的MAC地址，目标MAC改为了RIP的MAC地址，并将此包发送给RS。
- RS发现请求报文中的目的MAC是自己，就会将次报文接收下来，处理完请求报文后，将响应报文通过lo接口送给eth0网卡直接发送给client主机（cip）。


FULLNAT一个最大的问题是：RS无法获得用户IP，为了解决这个问题，又提出了TOA的概念，主要原理是：将cip放到了TCP Option里面带给后端RS，RS上通过toa内核模块hack了getname函数，给用户态返回TCP Option中的cid。

