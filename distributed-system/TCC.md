# 5.3.2 TCC

2007 年，数据库专家 Pat Helland 发表了一篇名为 “Life beyond Distributed Transactions:an Apostate’s Opinion” 的论文[^1]，提出了 TCC（Try-Confirm-Cancel）的概念，不过该论文中 TCC 还是以 Tentative-Confirmation-Cancellation 作为名称。在国内经历阿里程立博士的传道之后，TCC 逐渐被大家广为了解并接受。

:::tip 补偿机制

在分布式系统中，由于各个节点的执行可能存在时延、失败等情况，会导致分布式事务中参与者节点状态不一致，从而使得分布式事务无法完成。为了解决这个问题，我们需要引入一种机制来进行数据回滚。

这种回滚操作就叫做补偿，补偿机制指的是：在分布式事务出现异常时，通过一系列的操作，尽可能使得分布式事务状态回滚到之前的状态，从而避免分布式事务产生不一致的情况。

:::
TCC 是一种基于补偿事务的分布式事务模型，核心思想是**针对每个操作都要注册一个与其对应的确认（Try）和补偿（Cancel）**。如同名字，TCC 整个事务流程由三个阶段组成：

- **Try 阶段**：在这个阶段中，参与者会尝试执行事务，并将所有要修改的数据保存在一个本地事务中。如果所有的参与者都执行成功，那么它们就会向协调者报告这一事实。
- **Confirm 阶段**：如果所有的参与者都成功执行了 Try 阶段，那么协调者会向所有参与者发出确认提交的指令。在这个阶段中，参与者将提交事务，释放资源，并向协调者报告操作成功。
- **Cancel 阶段**：如果在 Try 阶段中有任何参与者执行失败，那么协调者会向所有参与者发出取消事务的指令。在这个阶段中，参与者将回滚事务，释放资源，并向协调者报告操作失败。

通过这些步骤，TCC 协议可以保证在分布式系统中的事务操作要么全部提交，要么全部回滚，从而确保了数据的一致性。

以一个下单服务为例，说明 TCC 事务处理流。该下单服务由两个系统操作完成：订单系统 X、资金账户系统 Y。

<div  align="center">
	<img src="../assets/tcc.png" width = "550"  align=center />
</div>

- **Try 操作** : try X 下单系统创建待支付订单。try Y 自己账户系统冻结订单金额 100 元。 
- **Confirm 操作**  confirm X 订单更新为支付成功。confirm Y 扣减账户系统 100 元。
- **Cancel 操作** Cancel X 订单异常，资金退回，Cancel Y 扣款异常，订单支付失败


TCC 事务模型虽然说起来简单，然而要基于 TCC 实现一个通用的分布式事务框架，却比它看上去要复杂的多，感知各个阶段的执行情况以及推进执行下一个阶段需要编写大量的逻辑代码，不只是调用一下 Confirm/Cancel 那么简单。通常的情况，我们不需要靠裸编码来实现 TCC，而是引入某些分布式事务中间件（譬如 Seata、ByteTCC）来降低编码工作，提升开发效率。

[^1]: 参见 http://adrianmarriott.net/logosroot/papers/LifeBeyondTxns.pdf