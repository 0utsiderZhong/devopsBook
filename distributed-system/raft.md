# 共识算法 Raft

多个成员组成集群，整体向外提供服务，当单个成员故障时，并不影响整体服务的可用性，这种设计的核心问题是多个成员如何保证数据对齐呢？答案就是状态机

状态机一词取于数学领域，它被定义为一组状态和一个转换函数。状态机从一个初始状态，每次输入都要传入转换函数，使得状态机进入一个新的状态，在下一个输入来之前，保持状态不变。

状态机具有确定性，一个确定的输入只会到达一个确定的状态。这个特性可以保证多个状态机从相同的初始状态开始，按照相同的顺序将一系列的输入传给转换函数之后，都会达到一致的状态。

我们将集群中的成员看成一个个状态机，如果所有的成员都从相同的初始状态开始启动且运行正常，并按照相同的输入顺序执行转换函数，那么最终所有成员状态都将是一致的。

状态机解决了集群满足容错性的必要条件，它被认为是一种实现容错服务的常规方法。


## 共识算法

基于状态机的分布式系统最关键的是决定输入的顺序，因为相同的输入顺序才能使得所有非错误的成员达到相同的状态。这才才能保证每个成员之间的数据一致性，并且能够构建无限多个一模一样的完整状态机。

为了使一组成员拥有相同顺序的一组输入，我们需要再状态机上再设计一个保证协议，这个协议就是共识算法。


### 共识与集群

在设计一个数据库服务时，为了满足容错性，需要多个成员同时提供数据库服务，在执行写操作时，如何使每个成员数据保持一致，有下面两种方案：

- 使用副本模式：副本模式约定特殊角色的成员如 Leader，让 Leader 执行写操作，然后将写请求再转发给副本成员 Slave。 但这种方式存在两个问题：
	- 数据延迟 Leader 写请求肯定再转发给 Slave，这存在一个中间状态。如果要获取最新的数据，只能将读写请求集中在 Leader 服务器，造成 Leader服务器压力过大。
	- 数据不一致 数据不一致的问题表现在 Leader 处理成功，但 Slave 因网络、自身问题处理失败，或者Leader发生故障， 导致 Leader 和 Slave 之间存在数据不一致的问题。

- 所有的成员都执行写操作： 在所有的成员写操作执行成功之后，本次写操作才算执行成功。 但这种方案一个是无法保证所有的成员都能成功，当一个成员失败时，整个系统就判断写入失败，要执行回滚，而回滚又可能发生错误...


因此共识问题只有通过共识算法才能解决。举例一个简单采用多数派决策的例子。如果一个写操作有多数成员执行成功，那么就认为该写操作已经达到共识，这种方式允许集群存在运行缓慢的成员，也允许一部分成员发生故障。而如何在多数派成员思想上提供正确的服务，就是 共识算法。

### 共识算法的定义

所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下，在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication）。

本质上，分布式事务和共识协议解决的两类问题：

- 2PC等协议解决的是分布式事务的一致性，存储的数据各有不同，目标侧重于ACID
- Paxos/raft 解决的是副本间数据的一致性和高可用，存储的数据完全一致，目标侧重于replication




### 共识算法 Raft


raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议，raft是一个paxos 协议衍生出来的共识算法（consensus algorithm）。


raft 算法将分布式一致性分解为多个子问题，包括 Leader 选举（Leader election）、日志复制（Log replication）、安全性（Safety）、日志压缩（Log compaction）等。

raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选者（Candidate）

- **Leader**：接受客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后高速Follower提交日志。
- **Follower**：接受并持久化 Leader 同步的日志，在 Leader 告知日志可以提交后，提交日志。当 Leader 出现故障时，主动推荐自己为候选人。
- **Candidate**：Leader 选举过程中的临时角色。向其他节点发送请求投票信息，如果获得大多数选票，则晋升为 Leader

<div  align="center">
	<img src="../assets/raft.png" width = "300"  align=center />
</div>

Raft算法将时间划分为不定长度的任期Terms，Terms为连续的数字。每个Term以选举开始，如果选举成功，则由当前leader负责出块，如果选举失败，并没有选举出新的单一Leader，则会开启新的Term，重新开始选举。

<div  align="center">
	<img src="../assets/raft-term.png" width = "350"  align=center />
</div>

### Leader 选举

Raft使用心跳机制来触发领导者选举，当服务器启动时，初始化都是Follower身份，由于没有Leader，Followers无法与Leader保持心跳，因此，Followers会认为Leader已经下线，进而转为Candidate状态，然后Candidate向集群其他节点请求投票，同意自己成为Leader，如果Candidate收到超过半数节点的投票(N/2 +1)，它将获胜成为Leader。

<div  align="center">
	<img src="../assets/raft-vote.png" width = "500"  align=center />
</div>

Leader 向所有 Follower 周期性发送 heartbeat，如果 Follower 在选举超时时间内没有收到 Leader 的 heartbeat，就会等待一段随机的时间后发起一次 Leader 选举。

<div  align="center">
	<img src="../assets/raft-vote-2.png" width = "500"  align=center />
</div>

### 日志同步

Raft算法实现日志同步的具体过程如下：

- Leader收到来自客户端的请求，将之封装成log entry并追加到自己的日志中；
- Leader并行地向系统中所有节点发送日志复制消息；
- 接收到消息的节点确认消息没有问题，则将log entry追加到自己的日志中，并向Leader返回ACK表示接收成功；
- Leader若在随机超时时间内收到大多数节点的ACK,则将该log entry应用到状态机并向客户端返回成功。

<div  align="center">
	<img src="../assets/raft-log.png" width = "500"  align=center />
</div>
