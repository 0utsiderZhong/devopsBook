# Service Mesh

ServiceMesh 又称服务网格。之所以称为服务网格，是因为每台节点同时运行着业务逻辑和代理。这个代理被形象地称为 Sidecar （业务逻辑相当于主驾驶，共享一个代理相当于边车），服务之间通过 Sidecar 发现和调用目标服务，从而在服务之间形成一种网络状依赖关系。然后通过一种独立部署称为 “控制平面”（Control Plane）的组件来集中管理这种依赖关系，以进行路由、流量调拨等操作。

如果我们把节点和业务逻辑从视图剥离，就会出现一种网络状的架构。服务网络由此得名。


<div  align="center">
	<img src="../assets/service-mesh.jpeg" width = "350"  align=center />
</div>

## 为什么要使用 Service Mesh

服务网格并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在云原生环境下的实现。

在 Service Mesh 之前，微服务架构所带来的问题都采用框架思维解决，将服务发现、熔断、限流、可观测性等能力以SDK的形式提供给开发人员。

随着业务发展和微服务规模不断增大，框架思维的架构瓶颈逐渐凸显，其一：单一的编程语言无法实现所有的业务需求，针对异构环境的服务治理框架实现往往存在差异，缺少共性问题的统一解决方案，各个编程语言的SDK维护和迭代困难。其二： SDK 和 应用在同一个进程内紧密耦合，这种强绑定关系使他们无法独立快速演进，从而陷入基础支撑技术和业务演进发展相互制约的困境。

Service Mesh 的出现使解决问题的思路从框架思维变成了平台思维，将之前SDK中非常固定的内容仍保留在SDK中，其他内容则剥离至完全独立的 Proxy（Sidecar）中。 Proxy 的热升级技术将平台功能变更对应用完全无感，实现了应用逻辑和服务治理能力解耦，从而最大程度解决了 框架SDK和业务耦合无法独立演进的问题。

在云原生架构下，容器的使用给予了异构应用程序的更多可行性，Kubernetes 增强的应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过分关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情而专注于程序开发，赋予开发者更多的创造性